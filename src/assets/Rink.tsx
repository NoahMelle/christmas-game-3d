/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from "three";
import { useGLTF } from "@react-three/drei";
import { GLTF, RGBELoader } from "three-stdlib";
import { CuboidCollider, RigidBody } from "@react-three/rapier";
import React, { useMemo, useRef } from "react";
import { useControls } from "leva";
import { degToRad } from "three/src/math/MathUtils.js";

type GLTFResult = GLTF & {
    nodes: {
        Cube608: THREE.Mesh;
        Cube608_1: THREE.Mesh;
        Cube608_2: THREE.Mesh;
    };
    materials: {
        ["Material.001"]: THREE.MeshStandardMaterial;
        ["glass.001"]: THREE.MeshStandardMaterial;
        ["Material.002"]: THREE.MeshStandardMaterial;
    };
};

export default function Rink({
    lookPosLeft,
    lookPosRight,
    rinkDimensions,
    ...props
}: Readonly<{
    lookPosLeft: React.MutableRefObject<THREE.Vector3>;
    lookPosRight: React.MutableRefObject<THREE.Vector3>;
    rinkDimensions: React.MutableRefObject<THREE.Vector3>;
}>) {
    const { nodes, materials, scene } = useGLTF("/rink.glb") as GLTFResult;
    const borderThickness = .4;
    const planeHeight = 0.7;
    const colliderThickness = 1;

    const cornerLength = 3;
    const cornerBoxDimensions = Math.sqrt(cornerLength ** 2 / 2);

    const wallDiagonal = Math.sqrt(2 * (borderThickness ** 2));

    const hdrEquirect = useRef(
        new RGBELoader().load("hdrs/rogland_clear_night_1k.hdr", () => {
            hdrEquirect.current.mapping =
                THREE.EquirectangularReflectionMapping;
        })
    );

    const glassMaterialProps = useControls({
        roughness: { value: 0, min: 0, max: 1, step: 0.1 },
        clearcoat: { value: 1, min: 0, max: 1, step: 0.1 },
        clearcoatRoughness: { value: 0, min: 0, max: 1, step: 0.1 },
        transmission: { value: 1, min: 0.9, max: 1, step: 0.01 },
        ior: { value: 1.25, min: 1, max: 2.3, step: 0.05 },
        color: "#000000",
        attenuationTint: "#ffe79e",
        attenuationDistance: { value: 0, min: 0, max: 1 },
    });

    const glassMaterial = useMemo(() => {
        return new THREE.MeshPhysicalMaterial({
            thickness: 0,
            roughness: 0,
            clearcoat: glassMaterialProps.clearcoat,
            reflectivity: 1,
            transparent: true,
            transmission: glassMaterialProps.transmission,
            envMapIntensity: 1,
            envMap: hdrEquirect.current,
            ior: 6,
            side: THREE.BackSide,
        });
    }, [glassMaterialProps]);

    const box = new THREE.Box3().setFromObject(scene);
    const size = box.getSize(new THREE.Vector3());

    rinkDimensions.current = size;

    console.log("Rendering rink");

    lookPosLeft.current = new THREE.Vector3(-size.x / 2, -4, -size.z / 2);
    lookPosRight.current = new THREE.Vector3(-size.x / 2, -4, size.z / 2);

    return (
        <RigidBody
            type="fixed"
            colliders={false}
            friction={0.01}
            linearDamping={0}
            angularDamping={0}
        >
            <group {...props} dispose={null}>
                <mesh
                    geometry={nodes.Cube608.geometry}
                    material={materials["Material.001"]}
                />
                <mesh
                    geometry={nodes.Cube608_1.geometry}
                    material={glassMaterial}
                />
                <mesh
                    geometry={nodes.Cube608_2.geometry}
                    material={materials["Material.002"]}
                />
                {/* Floor */}
                <CuboidCollider
                    args={[
                        size.x / 2 - borderThickness / 2,
                        0,
                        size.z / 2 - borderThickness / 2,
                    ]}
                    position={[0, planeHeight, 0]}
                />

                {/* Walls */}
                <CuboidCollider
                    args={[size.x / 2 - colliderThickness, 3, colliderThickness]}
                    position={[
                        0,
                        3 + planeHeight,
                        size.z / 2 + borderThickness,
                    ]}
                />
                <CuboidCollider
                    args={[size.x / 2 - colliderThickness, 3, colliderThickness]}
                    position={[
                        0,
                        3 + planeHeight,
                        -size.z / 2 - borderThickness,
                    ]}
                />
                <CuboidCollider
                    args={[colliderThickness, 3, size.z / 2 - colliderThickness]}
                    position={[
                        size.x / 2 + borderThickness,
                        3 + planeHeight,
                        0,
                    ]}
                />
                <CuboidCollider
                    args={[colliderThickness, 3, size.z / 2 - colliderThickness]}
                    position={[
                        -size.x / 2 - borderThickness,
                        3 + planeHeight,
                        0,
                    ]}
                />

                {/* Diagonal Corners */}
                <CuboidCollider
                    args={[3, 3, colliderThickness]}
                    position={[
                        size.x / 2 - borderThickness - cornerBoxDimensions + wallDiagonal,
                        3 + planeHeight,
                        size.z / 2 - borderThickness - cornerBoxDimensions + wallDiagonal,
                    ]}
                    rotation={[0, degToRad(45), 0]}
                />
                <CuboidCollider
                    args={[3, 3, colliderThickness]}
                    position={[
                        -size.x / 2 + borderThickness + cornerBoxDimensions - wallDiagonal,
                        3 + planeHeight,
                        size.z / 2 - borderThickness - cornerBoxDimensions + wallDiagonal,
                    ]}
                    rotation={[0, degToRad(-45), 0]}
                />
                <CuboidCollider
                    args={[3, 3, colliderThickness]}
                    position={[
                        size.x / 2 - borderThickness - cornerBoxDimensions + wallDiagonal,
                        3 + planeHeight,
                        -size.z / 2 + borderThickness + cornerBoxDimensions - wallDiagonal,
                    ]}
                    rotation={[0, degToRad(-45), 0]}
                />
                <CuboidCollider
                    args={[3, 3, colliderThickness]}
                    position={[
                        -size.x / 2 + borderThickness + cornerBoxDimensions - wallDiagonal,
                        3 + planeHeight,
                        -size.z / 2 + borderThickness + cornerBoxDimensions - wallDiagonal,
                    ]}
                    rotation={[0, degToRad(45), 0]}
                />

            </group>
        </RigidBody>
    );
}

useGLTF.preload("/rink.glb");
