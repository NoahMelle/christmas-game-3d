/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from "three";
import { MeshTransmissionMaterial, useGLTF } from "@react-three/drei";
import { GLTF } from "three-stdlib";
import { CuboidCollider, RigidBody } from "@react-three/rapier";
import React from "react";
import { degToRad } from "three/src/math/MathUtils.js";

type GLTFResult = GLTF & {
    nodes: {
        Cube608: THREE.Mesh;
        Cube608_1: THREE.Mesh;
        Cube608_2: THREE.Mesh;
    };
    materials: {
        ["Material.001"]: THREE.MeshStandardMaterial;
        ["glass.001"]: THREE.MeshStandardMaterial;
        ["Material.002"]: THREE.MeshStandardMaterial;
    };
};

export default function Rink({
    lookPosLeft,
    lookPosRight,
    rinkDimensions,
    ...props
}: Readonly<{
    lookPosLeft: React.MutableRefObject<THREE.Vector3>;
    lookPosRight: React.MutableRefObject<THREE.Vector3>;
    rinkDimensions: React.MutableRefObject<THREE.Vector3>;
}>) {
    const { nodes, materials, scene } = useGLTF("/rink.glb") as GLTFResult;
    const borderThickness = 0.6;
    const planeHeight = 0.7;
    const colliderThickness = 8;
    const cornerLength = 3;

    const box = new THREE.Box3().setFromObject(scene);
    const size = box.getSize(new THREE.Vector3());

    rinkDimensions.current = size;

    lookPosLeft.current = new THREE.Vector3(-size.x / 2, -4, -size.z / 2);
    lookPosRight.current = new THREE.Vector3(-size.x / 2, -4, size.z / 2);

    const cornerDistances = {
        x:
            size.x / 2 -
            borderThickness +
            ((Math.sqrt(2) / 2) * (colliderThickness + cornerLength)) / 2,
        z:
            size.z / 2 -
            borderThickness +
            ((Math.sqrt(2) / 2) * (colliderThickness + cornerLength)) / 2,
    };

    console.log(cornerDistances);

    return (
        <RigidBody
            type="fixed"
            colliders={false}
            friction={0.01}
            linearDamping={0}
            angularDamping={0}
        >
            <group {...props} dispose={null}>
                <mesh
                    geometry={nodes.Cube608.geometry}
                    material={materials["Material.001"]}
                />
                <mesh geometry={nodes.Cube608_1.geometry}>
                    {" "}
                    <MeshTransmissionMaterial
                        backside
                        samples={1}
                        thickness={0}
                        anisotropy={0.1}
                        distortion={0.1}
                        distortionScale={1}
                        temporalDistortion={1}
                        iridescence={1}
                        iridescenceIOR={1}
                        iridescenceThicknessRange={[0, 1400]}
                        reflectivity={1}
                    />
                </mesh>
                <mesh
                    geometry={nodes.Cube608_2.geometry}
                    material={materials["Material.002"]}
                />

                {/* Floor */}
                <CuboidCollider
                    args={[
                        size.x / 2 - borderThickness / 2,
                        0,
                        size.z / 2 - borderThickness / 2,
                    ]}
                    position={[0, planeHeight, 0]}
                />

                <Walls
                    colliderThickness={colliderThickness}
                    size={size}
                    borderThickness={borderThickness}
                    planeHeight={planeHeight}
                />

                <DiagonalWalls
                    colliderThickness={colliderThickness}
                    planeHeight={planeHeight}
                    cornerLength={cornerLength}
                    cornerDistances={cornerDistances}
                />
            </group>
        </RigidBody>
    );
}

const Walls = ({
    colliderThickness,
    size,
    borderThickness,
    planeHeight,
}: {
    colliderThickness: number;
    size: THREE.Vector3;
    borderThickness: number;
    planeHeight: number;
}) => {
    return (
        <group>
            <CuboidCollider
                args={[size.x / 2, 3, colliderThickness]}
                position={[
                    0,
                    3 + planeHeight,
                    size.z / 2 - borderThickness + colliderThickness,
                ]}
            />
            <CuboidCollider
                args={[size.x / 2, 3, colliderThickness]}
                position={[
                    0,
                    3 + planeHeight,
                    -size.z / 2 - colliderThickness + borderThickness,
                ]}
            />
            <CuboidCollider
                args={[colliderThickness, 3, size.z / 2]}
                position={[
                    size.x / 2 - borderThickness + colliderThickness,
                    3 + planeHeight,
                    0,
                ]}
            />
            <CuboidCollider
                args={[colliderThickness, 3, size.z / 2]}
                position={[
                    -size.x / 2 + borderThickness - colliderThickness,
                    3 + planeHeight,
                    0,
                ]}
            />
        </group>
    );
};

const DiagonalWalls = ({
    colliderThickness,
    planeHeight,
    cornerLength,
    cornerDistances,
}: {
    colliderThickness: number;
    planeHeight: number;
    cornerDistances: { x: number; z: number };
    cornerLength: number;
}) => {
    return (
        <group>
            <CuboidCollider
                args={[cornerLength, 3, colliderThickness]}
                position={[
                    cornerDistances.x,
                    3 + planeHeight,
                    cornerDistances.z,
                ]}
                rotation={[0, degToRad(45), 0]}
            />
            <CuboidCollider
                args={[cornerLength, 3, colliderThickness]}
                position={[
                    -cornerDistances.x,
                    3 + planeHeight,
                    cornerDistances.z,
                ]}
                rotation={[0, degToRad(-45), 0]}
            />
            <CuboidCollider
                args={[cornerLength, 3, colliderThickness]}
                position={[
                    cornerDistances.x,
                    3 + planeHeight,
                    -cornerDistances.z,
                ]}
                rotation={[0, degToRad(-45), 0]}
            />
            <CuboidCollider
                args={[cornerLength, 3, colliderThickness]}
                position={[
                    -cornerDistances.x,
                    3 + planeHeight,
                    -cornerDistances.z,
                ]}
                rotation={[0, degToRad(45), 0]}
            />
        </group>
    );
};

useGLTF.preload("/rink.glb");
